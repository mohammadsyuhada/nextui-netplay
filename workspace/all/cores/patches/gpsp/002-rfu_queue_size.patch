diff --git forkSrcPrefix/rfu.c forkDstPrefix/rfu.c
index 31a515c..a5e0b8f 100644
--- forkSrcPrefix/rfu.c
+++ forkDstPrefix/rfu.c
@@ -19,6 +19,10 @@

 #include "common.h"

+// Packet queue size for buffering network packets
+// Increased from 4 to handle TCP batching that delivers packets faster than game reads
+#define RFU_PKT_QUEUE_SIZE 16
+
 // Debug print logic:
 #ifdef RFU_DEBUG
   #define RFU_DEBUG_LOG(...) printf(__VA_ARGS__)
@@ -138,7 +142,7 @@ static struct {
     struct {
       u32 datalen;   // Byte count of data waiting to be polled.
       u8  data[16];  // Data received from client.
-    } pkts[4];
+    } pkts[RFU_PKT_QUEUE_SIZE];
   } clients[4];      // Connected clients IDs (zero means empty slot).
 } rfu_host;

@@ -146,11 +150,11 @@ static struct {
   u16 devid;         // Device ID assigned to the client (by the host?)
   u16 clnum;         // Client number (0 to 3)
   u16 host_id;       // Client ID for the host device.
-  // Store host recevied packets (up to 8!)
+  // Store host received packets
   struct {
     u16 hblen;       // Bytes received from the host.
     u8 hdata[128];   // Data received from the host (accumulated).
-  } pkts[4];
+  } pkts[RFU_PKT_QUEUE_SIZE];
 } rfu_client;

 typedef struct {
@@ -498,8 +502,8 @@ static s32 rfu_process_command() {
           rfu_buf[0] |= dlen << (8 + i * 5);
           // Discard front packet
           memmove(&rfu_host.clients[i].pkts[0], &rfu_host.clients[i].pkts[1],
-                  3 * sizeof(rfu_host.clients[i].pkts[0]));
-          rfu_host.clients[i].pkts[3].datalen = 0;
+                  (RFU_PKT_QUEUE_SIZE - 1) * sizeof(rfu_host.clients[i].pkts[0]));
+          rfu_host.clients[i].pkts[RFU_PKT_QUEUE_SIZE - 1].datalen = 0;
         }
       }
       // Copy data into words into the RFU buffer.
@@ -516,8 +520,8 @@ static s32 rfu_process_command() {
         rfu_buf[cnt++] = leupack32(&rfu_client.pkts[0].hdata[j*4]);

       // Move to the next packet
-      memmove(&rfu_client.pkts[0], &rfu_client.pkts[1], sizeof(rfu_client.pkts[0]) * 3);
-      rfu_client.pkts[3].hblen = 0;
+      memmove(&rfu_client.pkts[0], &rfu_client.pkts[1], sizeof(rfu_client.pkts[0]) * (RFU_PKT_QUEUE_SIZE - 1));
+      rfu_client.pkts[RFU_PKT_QUEUE_SIZE - 1].hblen = 0;
       return cnt;
     }
     break;
@@ -810,8 +814,8 @@ void rfu_net_receive(const void* buf, size_t len, uint16_t client_id) {
           // ACK the reception (so they know we are alive!)
           rfu_net_send_cmd(client_id, NET_RFU_CLIENT_ACK,
                            rfu_client.devid | (rfu_client.clnum << 16));
-          // Receive data from the host. Queue que packet if possible
-          for (i = 0; i < 4; i++) {
+          // Receive data from the host. Queue packet if possible
+          for (i = 0; i < RFU_PKT_QUEUE_SIZE; i++) {
             if (!rfu_client.pkts[i].hblen) {
               memcpy(&rfu_client.pkts[i].hdata, payl, blen);
               rfu_client.pkts[i].hblen = blen;
@@ -835,7 +839,7 @@ void rfu_net_receive(const void* buf, size_t len, uint16_t client_id) {
         // Validate the slot with device ID
         if (rfu_host.clients[clid].devid == cdevid) {
           rfu_host.clients[clid].clttl = 0;   // Account for packet reception
-          for (i = 0; i < 4; i++) {
+          for (i = 0; i < RFU_PKT_QUEUE_SIZE; i++) {
             if (!rfu_host.clients[clid].pkts[i].datalen) {
               memcpy(rfu_host.clients[clid].pkts[i].data, payl, blen);
               rfu_host.clients[clid].pkts[i].datalen = blen;

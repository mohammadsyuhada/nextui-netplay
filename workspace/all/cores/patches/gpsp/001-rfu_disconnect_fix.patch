diff --git forkSrcPrefix/libretro/libretro.c forkDstPrefix/libretro/libretro.c
index 8069103..a288e2c 100644
--- forkSrcPrefix/libretro/libretro.c
+++ forkDstPrefix/libretro/libretro.c
@@ -490,7 +490,13 @@ static bool netpacket_connected(uint16_t client_id) {
   return true;
 }
 
+// Forward declaration for RFU disconnect
+void rfu_net_disconnect(void);
+
 static void netpacket_disconnected(uint16_t client_id) {
+  // Force RFU state to IDLE so the game receives disconnect notification
+  // This fixes CLIENT getting stuck when HOST disconnects during gameplay
+  rfu_net_disconnect();
   netplay_num_clients--;
 }
 
diff --git forkSrcPrefix/rfu.c forkDstPrefix/rfu.c
index 31a515c..33fbc57 100644
--- forkSrcPrefix/rfu.c
+++ forkDstPrefix/rfu.c
@@ -119,6 +119,9 @@ static u32 rfu_prev_data;
 static u32 rfu_comstate, rfu_cnt, rfu_state;
 static u32 rfu_buf[255];
 static u8 rfu_cmd, rfu_plen;
+// Flag to force disconnect response on next command
+static bool rfu_disconnect_pending = false;
+
 static u32 rfu_timeout_cycles, rfu_resp_timeout;
 static u8 rfu_timeout, rfu_rtx_max;
 
@@ -242,11 +245,32 @@ void rfu_reset() {
   // Clear all the received broadcasts.
   memset(&rfu_peer_bcst, 0, sizeof(rfu_peer_bcst));
 
+  // Clear any pending disconnect from previous session
+  rfu_disconnect_pending = false;
+
   // Re-seed random gen.
   rand_seed(time(NULL));
   rand_seed(cpu_ticks);
 }
 
+// Called when the network link is lost (netpacket disconnect callback).
+// Clears connection state and sets disconnect pending flag.
+// The next RFU command will be forced to WAIT, triggering disconnect response.
+void rfu_net_disconnect(void) {
+  RFU_DEBUG_LOG("RFU net disconnect! state=%d comstate=%d\n", rfu_state, rfu_comstate);
+
+  // Clear all connection data based on current role
+  if (rfu_state == RFU_STATE_HOST) {
+    memset(&rfu_host.clients, 0, sizeof(rfu_host.clients));
+  } else if (rfu_state == RFU_STATE_CLIENT) {
+    memset(&rfu_client, 0, sizeof(rfu_client));
+  }
+
+  // Force IDLE state and mark disconnect pending
+  rfu_state = RFU_STATE_IDLE;
+  rfu_disconnect_pending = true;
+}
+
 static u16 new_devid() {
   while (1) {
     u16 n = rand_gen() ^ time(NULL);
@@ -593,9 +617,17 @@ u32 rfu_transfer(u32 sent_value) {
   case RFU_COMSTATE_WAITCMD:
     // Wait for a new command, verify its header.
     if ((sent_value >> 16) == 0x9966) {
-      rfu_plen = (u8)(sent_value >> 8);
-      rfu_cmd  = (u8)(sent_value);
-      rfu_cnt = 0;
+      // Check for pending disconnect - force WAIT command to trigger disconnect response
+      if (rfu_disconnect_pending && rfu_state == RFU_STATE_IDLE) {
+        rfu_cmd = RFU_CMD_WAIT;
+        rfu_plen = 0;
+        rfu_cnt = 0;
+        rfu_disconnect_pending = false;
+      } else {
+        rfu_plen = (u8)(sent_value >> 8);
+        rfu_cmd  = (u8)(sent_value);
+        rfu_cnt = 0;
+      }
       if (!rfu_plen) {
         // Returns error code or response length
         s32 ret = rfu_process_command();
diff --git forkSrcPrefix/serial.h forkDstPrefix/serial.h
index d006423..a346f07 100644
--- forkSrcPrefix/serial.h
+++ forkDstPrefix/serial.h
@@ -39,6 +39,7 @@ bool update_serial(unsigned cycles);
 void rfu_reset(void);
 bool rfu_update(unsigned cycles);
 u32 rfu_transfer(u32 value);
+void rfu_net_disconnect(void);
 void rfu_frame_update(void);
 void rfu_net_receive(const void* buf, size_t len, uint16_t client_id);
 
